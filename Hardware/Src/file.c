#include "file.h"
#include "print.h"
#include "fatfs.h"

/******************************************************************************/
FILE_PatchPackTypedef FILE_PatchPack;		/* 补传文件信息 */
uint64_t FILE_DataSaveStructCnt;			/* 数据储存文件结构体总数 */


FILE_SaveStructTypedef FILE_SaveStruct;			/* 储存信息写入结构体 */
FILE_SaveStructTypedef FILE_ReadStruct[GPRS_PATCH_PACK_NUMB_MAX];
												/* 储存信息读取结构体 */

/******************************************************************************/
static void Data2SaveFormat(RT_TimeTypedef* time, GPS_LocateTypedef* location);
static void SendInfoFormatConvert(uint8_t* sendInfo,
							      uint8_t* readInfo,
							      uint8_t  sendPackNumb);
static void SaveStructSymbolInit(void);

/*******************************************************************************
 * function：文件系统初始化，获取数据储存文件的结构体总数
 */
void FILE_Init(void)
{
	/* 挂载文件系统 */
	if (ERROR == FATFS_FileLink())
		return;

	/* 打开文件，如果不存在则先创建文件，确保设备存在必要的文件 */
	FATFS_FileOpen(FILE_NAME_SAVE_DATA, FATFS_MODE_OPNE_ALWAYS);
	FATFS_FileClose();
	FATFS_FileOpen(FILE_NAME_PATCH_PACK, FATFS_MODE_OPNE_ALWAYS);
	FATFS_FileClose();
	FATFS_FileOpen(FILE_NAME_PARAM, FATFS_MODE_OPNE_ALWAYS);
	FATFS_FileClose();

	/* 读数据文件的结构体大小 */
	if (SUCCESS == FATFS_FileOpen(FILE_NAME_SAVE_DATA, FATFS_MODE_OPEN_EXISTING_READ))
	{
		FILE_DataSaveStructCnt = FATFS_GetFileStructCount();
		PARAM_DeviceParam.deviceCapacity = FATFS_GetSpaceInfo();
	}

	FATFS_FileClose();
	FATFS_FileUnlink();

	/* 储存数据结构初始化 */
	SaveStructSymbolInit();
}

/*******************************************************************************
 * function:储存结构体到Flash
 * saveInfo：储存结构体指针
 * fileStructCount：当前文件结构体数
 */
ErrorStatus FILE_SaveInfo(RT_TimeTypedef* time, GPS_LocateTypedef* location)
{
	/* 数据转换成ASCII储存格式 */
	Data2SaveFormat(time, location);

	/* 挂载文件系统 */
	if (ERROR == FATFS_FileLink())
		return ERROR;

	/* 获取文件，文件名存在则打开写入，不存在则创建写入 */
	if (SUCCESS == FATFS_FileOpen(FILE_NAME_SAVE_DATA, FATFS_MODE_OPEN_ALWAYS_WRITE))
	{
		/* 先判断写入地址是否对齐，对齐才写入，不对齐则覆盖不对齐的数据 */
		FATFS_FileSeekSaveInfoStructAlign();

		/* 把结构体写入文件 */
		FATFS_FileWrite((BYTE*)&FILE_SaveStruct, sizeof(FILE_SaveStructTypedef));

		/* 获取文件大小 */
		FILE_DataSaveStructCnt = FATFS_GetFileStructCount();
	}

	FATFS_FileClose();

	FATFS_FileUnlink();

	return SUCCESS;
}

/*******************************************************************************
 * function：从Flash中读出最近一个结构体
 * readInfo：储存读出结构体指针
 * @patch：补传信息
 */
void FILE_ReadInfo(GPRS_SendBufferTypedef* sendBuffer,
				   FILE_PatchPackTypedef*  patch)
{
	uint8_t readInfoCount;

	/* 挂载文件系统 */
	if (ERROR == FATFS_FileLink())
		return;

	/* 打开数据储存文件 */
	if (SUCCESS == FATFS_FileOpen(FILE_NAME_SAVE_DATA, FATFS_MODE_OPEN_EXISTING_READ))
	{
		/* 没有补传数据 */
		if (patch->patchStructOffset == 0)
		{
			/* 读取数据为1组 */
			readInfoCount = 1;
			/* 指针指向最后一个结构体 */
			FATFS_FileSeekBackwardOnePack();
		}
		else
		{
			/* 有补传数据 */
			FATFS_FileSeek(patch->patchStructOffset
						   * sizeof(FILE_SaveStructTypedef));

			/* 当前文件还有多少个结构体可以读 */
			readInfoCount = FATFS_GetFileStructCount() - patch->patchStructOffset;

			/* 文件中结构体数不能一次读完 */
			if (readInfoCount > GPRS_PATCH_PACK_NUMB_MAX)
			{
				/* 最大上传的数据组数 */
				readInfoCount = GPRS_PATCH_PACK_NUMB_MAX;
				patch->patchStructOffset += GPRS_PATCH_PACK_NUMB_MAX;
			}
			/* 当前文件剩余的结构体能够被一次读完 */
			else
			{
				/* 补传数据清空 */
				patch->patchStructOffset = 0;
			}
		}
		FATFS_FileRead((BYTE*)FILE_ReadStruct,
							(readInfoCount * sizeof(FILE_SaveStructTypedef)));
	}

	FATFS_FileClose();
	FATFS_FileUnlink();

	/* 获取发送的数据包数 */
	sendBuffer->dataPackNumbL = HALFWORD_BYTE_L(readInfoCount);
	/* 将读出的数据格式转换成协议格式 */
	SendInfoFormatConvert((uint8_t*)&sendBuffer->dataPack,
						  (uint8_t*)FILE_ReadStruct,
						  readInfoCount);
}

/*******************************************************************************
 * function：读文件
 * @offset:读指针偏移量
 * @fileName:文件名
 * @pBuffer：接收指针
 * @size:读取长度
 */
ErrorStatus FILE_ReadFile(char* fileName, uint64_t offset, BYTE* pBuffer, uint32_t size)
{
	/* 挂载文件系统 */
	if (FATFS_FileLink() == ERROR)
		return ERROR;

	if (FATFS_FileOpen(fileName, FATFS_MODE_OPEN_EXISTING_READ) == SUCCESS)
	{
		if (offset % sizeof(FILE_SaveStructTypedef) == 0)
		{
			FATFS_FileSeek(offset);
			FATFS_FileRead(pBuffer, size);
		}
	}

	FATFS_FileClose();
	FATFS_FileUnlink();

	return SUCCESS;
}

/*******************************************************************************
 * function：写文件
 * @offset:写指针偏移量
 * @fileName:文件名
 * @pBuffer：写入指针
 * @size:写入长度
 */
ErrorStatus FILE_WriteFile(char* fileName, uint64_t offset, BYTE* pBuffer, uint32_t size)
{
	/* 挂载文件系统 */
	if (ERROR == FATFS_FileLink())
		return ERROR;

	if (FATFS_FileOpen(fileName, FATFS_MODE_OPEN_ALWAYS_WRITE) == SUCCESS)
	{
		FATFS_FileSeek(offset);

		FATFS_FileWrite(pBuffer, size);
	}

	FATFS_FileClose();

	FATFS_FileUnlink();

	return SUCCESS;
}

/*******************************************************************************
 * @brief 将储存的ASCII码转换成float
 * @retval 模拟量ASCII码
 */
float FILE_Analog2Float(SaveInfoAnalogTypedef* value)
{
	char str[6];

	memcpy(str, value->value, 5);
	str[5] = '\0';
	return (float)atof(str);
}

/*******************************************************************************
 * @brief 把数据转换成储存格式
 */
static void Data2SaveFormat(RT_TimeTypedef* time, GPS_LocateTypedef* location)
{
	/* 时间转换成ASCII */
	HEX2ASCII((uint8_t*)&FILE_SaveStruct.year[0],  &time->date.Year,    1);
	HEX2ASCII((uint8_t*)&FILE_SaveStruct.month[0], &time->date.Month,   1);
	HEX2ASCII((uint8_t*)&FILE_SaveStruct.day[0],   &time->date.Date,    1);
	HEX2ASCII((uint8_t*)&FILE_SaveStruct.hour[0],  &time->time.Hours,   1);
	HEX2ASCII((uint8_t*)&FILE_SaveStruct.min[0],   &time->time.Minutes, 1);
	HEX2ASCII((uint8_t*)&FILE_SaveStruct.sec[0],   &time->time.Seconds, 1);

	/* 获取外部电源状态 */
	FILE_SaveStruct.exPwrStatus = INPUT_CheckPwrOnStatus() + '0';

	/* 模拟量转换为ASCII */
	sprintf((char*)&FILE_SaveStruct.analogValue[0].value, "%5.1f", ANALOG_value.temp1);
	sprintf((char*)&FILE_SaveStruct.analogValue[1].value, "%5.1f", ANALOG_value.humi1);
	sprintf((char*)&FILE_SaveStruct.analogValue[2].value, "%5.1f", ANALOG_value.temp2);
	sprintf((char*)&FILE_SaveStruct.analogValue[3].value, "%5.1f", ANALOG_value.humi2);
	sprintf((char*)&FILE_SaveStruct.analogValue[4].value, "%5.1f", ANALOG_value.temp3);
	sprintf((char*)&FILE_SaveStruct.analogValue[5].value, "%5.1f", ANALOG_value.humi3);
	sprintf((char*)&FILE_SaveStruct.analogValue[6].value, "%5.1f", ANALOG_value.temp4);
	sprintf((char*)&FILE_SaveStruct.analogValue[7].value, "%5.1f", ANALOG_value.humi4);
	sprintf((char*)&FILE_SaveStruct.batQuality[0],        "%3d",   ANALOG_value.batVoltage);

	/* 定位值转换成ASCII */
	sprintf((char*)&FILE_SaveStruct.longitude[0], "%10.5f", location->longitude);
	sprintf((char*)&FILE_SaveStruct.latitude[0],  "%10.5f",  location->latitude);

	FILE_SaveStruct.batQuality[3]	   = '%';		/* 电池电量百分号 */
	FILE_SaveStruct.str7   			   = ',';
	FILE_SaveStruct.str8   			   = ',';
	FILE_SaveStruct.analogValue[0].str = ',';
	FILE_SaveStruct.analogValue[1].str = ',';
	FILE_SaveStruct.analogValue[2].str = ',';
	FILE_SaveStruct.analogValue[3].str = ',';
	FILE_SaveStruct.analogValue[4].str = ',';
	FILE_SaveStruct.analogValue[5].str = ',';
	FILE_SaveStruct.analogValue[6].str = ',';
	FILE_SaveStruct.analogValue[7].str = ',';
}

/*******************************************************************************
 * function:模拟量数据格式转换
 */
static void AnalogDataFormatConvert(char* analog, DataFormatEnum format, uint8_t* pBuffer)
{
	char str[6];
	float value;
	BOOL negative = FALSE;
	uint16_t temp = 0;

	/* 将字符串转为float */
	memcpy(str, analog, 5);
	str[5] = '\0';
	value = (float)atof(str);

	/* 判断是否为负数 */
	if (value < 0)
		negative = TRUE;

	switch (format)
	{
	case FORMAT_INT:
		temp = (uint16_t)abs((int)(value));
		break;

	case FORMAT_ONE_DECIMAL:
		temp = (uint16_t)abs((int)(value * 10));
		break;

	case FORMAT_TWO_DECIMAL:
		temp = (uint16_t)abs((int)(value * 100));
		break;
	default:
		break;
	}

	*pBuffer = HALFWORD_BYTE_H(temp);
	*(pBuffer + 1) = HALFWORD_BYTE_L(temp);

	/* 负数则最高位置一 */
	if (negative)
		*pBuffer |= 0x80;
}

/*******************************************************************************
 * @brief 将字符串型的定位值转换成协议格式
 */
static void LocationFormatConvert(char* lacation, uint8_t* pBuffer)
{
	char str[11];
	double value;
	BOOL negative = FALSE;
	uint32_t temp;

	/* 将字符串转为double */
	memcpy(str, lacation, 10);
	str[10] = '\0';
	value = atof(str);

	if (value < 0)
		negative = TRUE;

	/* 获取整数部分 */
	*pBuffer = abs((int)value);

	temp = (uint32_t)((value - (*pBuffer)) * 1000000);

	if (negative)
		temp |= 0x800000;

	*(pBuffer + 1) = (uint8_t)((temp & 0x00FF0000) >> 16);
	*(pBuffer + 2) = (uint8_t)((temp & 0x0000FF00) >> 8);
	*(pBuffer + 3) = (uint8_t)(temp & 0x000000FF);
}

/*******************************************************************************
 * @brief 将储存的格式（ASCII码）转换成协议规定的格式
 */
static void FormatConvert(GPRS_SendInfoTypedef*   sendInfo,
						  FILE_SaveStructTypedef* readInfo)
{
	char str[4];

	/* 结构体复位，避免数据出错 */
	memset(sendInfo, 0, sizeof(GPRS_SendInfoTypedef));

	/* 时间字符串转换成BCD */
	ASCII2BCD(&sendInfo->year,  readInfo->year,  2);
	ASCII2BCD(&sendInfo->month, readInfo->month, 2);
	ASCII2BCD(&sendInfo->day,   readInfo->day,   2);
	ASCII2BCD(&sendInfo->hour,  readInfo->hour,  2);
	ASCII2BCD(&sendInfo->min,   readInfo->min,   2);
	ASCII2BCD(&sendInfo->sec,   readInfo->sec,   2);

	/* 转换电池电量 */
	memcpy(str, readInfo->batQuality, 3);
	str[3] = '\0';
	sendInfo->batteryLevel = atoi(str);

	/* 转换外部电源状态 */
	str2numb(&sendInfo->externalPowerStatus, (uint8_t*)&readInfo->exPwrStatus, 1);

	/* 转换经度 */
	LocationFormatConvert(readInfo->longitude, (uint8_t*)&sendInfo->longitude);
	LocationFormatConvert(readInfo->latitude,  (uint8_t*)&sendInfo->latitude);

	AnalogDataFormatConvert(readInfo->analogValue[0].value, ANALOG_VALUE_FORMAT,
			(uint8_t*)&sendInfo->analogValue[0]);
	AnalogDataFormatConvert(readInfo->analogValue[1].value, ANALOG_VALUE_FORMAT,
			(uint8_t*)&sendInfo->analogValue[1]);
	AnalogDataFormatConvert(readInfo->analogValue[2].value, ANALOG_VALUE_FORMAT,
			(uint8_t*)&sendInfo->analogValue[2]);
	AnalogDataFormatConvert(readInfo->analogValue[3].value, ANALOG_VALUE_FORMAT,
			(uint8_t*)&sendInfo->analogValue[3]);
	AnalogDataFormatConvert(readInfo->analogValue[4].value, ANALOG_VALUE_FORMAT,
			(uint8_t*)&sendInfo->analogValue[4]);
	AnalogDataFormatConvert(readInfo->analogValue[5].value, ANALOG_VALUE_FORMAT,
			(uint8_t*)&sendInfo->analogValue[5]);
	AnalogDataFormatConvert(readInfo->analogValue[6].value, ANALOG_VALUE_FORMAT,
			(uint8_t*)&sendInfo->analogValue[6]);
	AnalogDataFormatConvert(readInfo->analogValue[7].value, ANALOG_VALUE_FORMAT,
			(uint8_t*)&sendInfo->analogValue[7]);
}

/*******************************************************************************
 * @brief 将读出的数据转换成发送的格式
 * @param sendInfo：发送数据结构体指针
 * @param readInfo：读取数据的结构体指针
 * @param sendPackNumb：需要转换的包数
 */
static void SendInfoFormatConvert(uint8_t* sendInfo,
						   uint8_t* readInfo,
						   uint8_t  sendPackNumb)
{
	uint8_t i;

	for (i = 0; i < sendPackNumb; i++)
	{
		FormatConvert((GPRS_SendInfoTypedef*)sendInfo, (FILE_SaveStructTypedef*)readInfo);
		readInfo += sizeof(FILE_SaveStructTypedef);
		sendInfo += sizeof(GPRS_SendInfoTypedef);
	}
}

/*******************************************************************************
 * @brief 数据储存结构体中添加符号，使其能用Excel软件打开
 */
static void SaveStructSymbolInit(void)
{
	FILE_SaveStruct.str1   = ' ';
	FILE_SaveStruct.str2   = ':';
	FILE_SaveStruct.str3   = ':';
	FILE_SaveStruct.str4   = ',';
	FILE_SaveStruct.str5   = ',';
	FILE_SaveStruct.str6   = ',';
	FILE_SaveStruct.end[0] = 0x0D;
	FILE_SaveStruct.end[1] = 0x0A;
}
























